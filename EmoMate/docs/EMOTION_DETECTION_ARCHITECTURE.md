# æƒ…ç»ªæ£€æµ‹æŠ€æœ¯æ¶æ„æ–‡æ¡£

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

### å¤šå±‚æ¶æ„è®¾è®¡
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    UI Layer (React Native)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  BasicEmotionDetector  â”‚  EmotionAwareCharacter  â”‚  UIç»„ä»¶  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Business Logic Layer                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚     EmotionProvider    â”‚    EmotionAnalysis    â”‚   Debug    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Data Layer & APIs                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Expo Camera API     â”‚     Zustand Store     â”‚  Context   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Platform Layer                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      iOS (Swift)      â”‚    Android (Kotlin)   â”‚   Hermes   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. BasicEmotionDetector ç»„ä»¶

#### ç»„ä»¶èŒè´£
- **ä¸»è¦èŒè´£**: é¢éƒ¨æƒ…ç»ªæ£€æµ‹å’Œç”¨æˆ·äº¤äº’
- **è¾“å…¥**: æ‘„åƒå¤´è§†é¢‘æµ
- **è¾“å‡º**: EmotionType æƒ…ç»ªäº‹ä»¶
- **UIç‰¹æ€§**: å¯æ‹–æ‹½ã€åŠ¨ç”»åé¦ˆã€çŠ¶æ€æŒ‡ç¤º

#### æŠ€æœ¯å®ç°
```typescript
// æ ¸å¿ƒHookç»„åˆ
const BasicEmotionDetector: React.FC<EmotionDetectorProps> = (props) => {
  // 1. æƒé™ç®¡ç†
  const [permission, requestPermission] = useCameraPermissions();
  
  // 2. åŠ¨ç”»ç³»ç»Ÿ  
  const scale = useSharedValue(1);
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: scale.value }]
  }));
  
  // 3. æ‹–æ‹½å¤„ç†
  const panResponder = PanResponder.create({...});
  
  // 4. æ™ºèƒ½æƒ…ç»ªç®—æ³•
  const simulateEmotionDetection = useCallback(() => {
    // æ—¶é—´æ„ŸçŸ¥ + æƒé‡éšæœºç®—æ³•
  }, []);
  
  // 5. ç”Ÿå‘½å‘¨æœŸç®¡ç†
  useEffect(() => { /* å®šæ—¶å™¨å’Œæ¸…ç† */ }, []);
};
```

#### ç®—æ³•æ ¸å¿ƒ: æ™ºèƒ½æƒ…ç»ªæ¨¡æ‹Ÿ
```typescript
interface EmotionWeights {
  happy: number;
  neutral: number; 
  surprised: number;
  sad: number;
  angry: number;
}

// æ—¶é—´æ„ŸçŸ¥æƒé‡è®¡ç®—
const calculateEmotionWeights = (hour: number): EmotionWeights => {
  if (hour >= 6 && hour < 12) {
    // æ—©ä¸Š: ç§¯ææƒ…ç»ªåé‡
    return { happy: 0.4, neutral: 0.4, surprised: 0.15, sad: 0.03, angry: 0.02 };
  } else if (hour >= 12 && hour < 18) {
    // ä¸‹åˆ: å¹³è¡¡åˆ†å¸ƒ
    return { happy: 0.3, neutral: 0.5, surprised: 0.1, sad: 0.07, angry: 0.03 };
  } else {
    // æ™šä¸Š: å¹³é™ä¸ºä¸»
    return { happy: 0.25, neutral: 0.6, surprised: 0.08, sad: 0.05, angry: 0.02 };
  }
};

// ç´¯ç§¯æ¦‚ç‡é€‰æ‹©ç®—æ³•
const selectEmotionByWeight = (weights: EmotionWeights): EmotionType => {
  const rand = Math.random();
  let cumulative = 0;
  
  for (const [emotion, weight] of Object.entries(weights)) {
    cumulative += weight;
    if (rand <= cumulative) {
      return emotion as EmotionType;
    }
  }
  return 'neutral';
};
```

### 2. EmotionProvider çŠ¶æ€ç®¡ç†

#### Contextæ¶æ„
```typescript
interface EmotionContextType {
  // çŠ¶æ€è¯»å–
  facialEmotion: EmotionType | null;
  textEmotion: EmotionType | null;
  combinedEmotion: EmotionType;
  lastUpdated: number;
  
  // çŠ¶æ€æ›´æ–°
  setFacialEmotion: (emotion: EmotionType) => void;
  setTextEmotion: (emotion: EmotionType) => void;
}

// ç»„åˆæƒ…ç»ªè®¡ç®—é€»è¾‘
const calculateCombinedEmotion = (
  facial: EmotionType | null,
  text: EmotionType | null
): EmotionType => {
  // 1. é¢éƒ¨æ£€æµ‹ä¼˜å…ˆç­–ç•¥
  if (facial && facial !== 'neutral') return facial;
  
  // 2. æ–‡æœ¬æƒ…ç»ªè¡¥å……ç­–ç•¥  
  if (text && text !== 'neutral') return text;
  
  // 3. é»˜è®¤ä¸­æ€§çŠ¶æ€
  return 'neutral';
};
```

#### çŠ¶æ€æŒä¹…åŒ–
```typescript
// Zustandé›†æˆ (å¯é€‰)
interface EmotionStore {
  emotionHistory: EmotionDetectionResult[];
  addEmotionLog: (emotion: EmotionType) => void;
  getEmotionStats: () => EmotionStats;
}

const useEmotionStore = create<EmotionStore>()(
  immer((set, get) => ({
    emotionHistory: [],
    addEmotionLog: (emotion) => set((state) => {
      state.emotionHistory.push({
        emotion,
        confidence: 0.8, // æ¨¡æ‹Ÿç½®ä¿¡åº¦
        timestamp: Date.now()
      });
    }),
    getEmotionStats: () => {
      // ç»Ÿè®¡åˆ†æé€»è¾‘
    }
  }))
);
```

### 3. EmotionAwareCharacter å“åº”ç³»ç»Ÿ

#### æƒ…ç»ªæ˜ å°„ç­–ç•¥
```typescript
// æƒ…ç»ªåˆ°åŠ¨ç”»çš„æ˜ å°„è¡¨
const EMOTION_ANIMATION_MAP: Record<EmotionType, string> = {
  happy: 'Happy',
  sad: 'Sad',
  surprised: 'Surprised', 
  angry: 'Angry',
  neutral: 'Idle'
};

// Live2Dé›†æˆé€»è¾‘
const EmotionAwareCharacter: React.FC = () => {
  const { combinedEmotion } = useEmotionContext();
  
  useEffect(() => {
    const animation = EMOTION_ANIMATION_MAP[combinedEmotion];
    // è§¦å‘Live2DåŠ¨ç”»
    triggerHiyoriAnimation(animation);
  }, [combinedEmotion]);
  
  return <Live2DCharacter />;
};
```

---

## ğŸ”§ ä¾èµ–å…³ç³»å’Œç‰ˆæœ¬ç­–ç•¥

### å½“å‰ç¨³å®šæŠ€æœ¯æ ˆ
```json
{
  "core": {
    "react": "19.0.0",
    "react-native": "0.79.5",
    "expo": "53.0.20",
    "typescript": "~5.8.3"
  },
  "camera": {
    "expo-camera": "~16.1.11"
  },
  "animation": {
    "react-native-reanimated": "~3.17.4",
    "react-native-gesture-handler": "~2.24.0"
  },
  "future": {
    "react-native-vision-camera": "^4.7.1",
    "react-native-worklets-core": "^1.6.0"
  }
}
```

### ç‰ˆæœ¬ç­–ç•¥åˆ†æ

#### âœ… å½“å‰ç¨³å®šç»„åˆ
- **Expo Camera**: æˆç†Ÿç¨³å®šï¼ŒiOS/Androidå…¼å®¹æ€§å¥½
- **Reanimated 3.17**: ä¸RN 0.79.5å®Œç¾é…åˆ
- **Gesture Handler**: æ‹–æ‹½åŠŸèƒ½æ— å†²çª

#### ğŸ”„ é¢„ç•™å‡çº§è·¯å¾„
```typescript
// Phase 2: çœŸå®MLKité›†æˆå‡†å¤‡
import {
  useCameraDevice, 
  useFrameProcessor,
  Camera as VisionCamera
} from 'react-native-vision-camera';

// Phase 3: è‡ªå®šä¹‰Frame Processor
const faceDetectionProcessor = useFrameProcessor((frame) => {
  'worklet';
  // ç›´æ¥è°ƒç”¨MLKit Native API
  const faces = detectFacesNative(frame);
  // ç»•è¿‡face-detectoråŒ…çš„ä¾èµ–é—®é¢˜
}, []);
```

#### âŒ å·²è§£å†³çš„ä¾èµ–å†²çª
```bash
# ç§»é™¤çš„é—®é¢˜åŒ…
react-native-vision-camera-face-detector@1.8.6

# å†²çªåŸå› åˆ†æ
react-native-vision-camera-face-detector â†’ react-native-worklets-core@1.5.0
react-native-reanimated@3.17.4 â†’ react-native-worklets-core@1.3.x
# ç‰ˆæœ¬ä¸å…¼å®¹å¯¼è‡´Metro bundlerè§£æå¤±è´¥
```

---

## ğŸ¨ UI/UXè®¾è®¡æ¨¡å¼

### 1. å“åº”å¼æ‹–æ‹½ç³»ç»Ÿ

#### æ‰‹åŠ¿å¤„ç†æ¶æ„
```typescript
const createDragGesture = () => {
  const position = useSharedValue({ x: 20, y: 80 });
  const scale = useSharedValue(1);
  
  return PanResponder.create({
    onMoveShouldSetPanResponder: () => true,
    onPanResponderGrant: () => {
      // æ‹–æ‹½å¼€å§‹: ç¼©æ”¾åé¦ˆ
      scale.value = withSpring(0.95);
    },
    onPanResponderMove: (_, gestureState) => {
      // å®æ—¶ä½ç½®æ›´æ–° + è¾¹ç•Œé™åˆ¶
      const newX = Math.max(0, Math.min(SCREEN_WIDTH - WIDTH, 
        position.value.x + gestureState.dx));
      const newY = Math.max(0, Math.min(SCREEN_HEIGHT - HEIGHT,
        position.value.y + gestureState.dy));
      position.value = { x: newX, y: newY };
    },
    onPanResponderRelease: () => {
      // æ‹–æ‹½ç»“æŸ: æ¢å¤ç¼©æ”¾
      scale.value = withSpring(1);
    }
  });
};
```

#### è§†è§‰åé¦ˆç³»ç»Ÿ
```typescript
// æƒ…ç»ªçŠ¶æ€è§†è§‰æ˜ å°„
const getEmotionStyle = (emotion: EmotionType, isActive: boolean) => ({
  borderColor: isActive ? EMOTION_COLORS[emotion] : '#e9ecef',
  backgroundColor: isActive ? 
    `${EMOTION_COLORS[emotion]}20` : '#f8f9fa',
  transform: [
    { scale: isActive ? 1.05 : 1 }
  ]
});

const EMOTION_COLORS = {
  happy: '#22c55e',    // ç»¿è‰²
  sad: '#3b82f6',      // è“è‰²  
  surprised: '#f59e0b', // æ©™è‰²
  angry: '#ef4444',    // çº¢è‰²
  neutral: '#6b7280'   // ç°è‰²
};
```

### 2. çŠ¶æ€æŒ‡ç¤ºå™¨è®¾è®¡

#### å¤šå±‚æ¬¡åé¦ˆ
```typescript
// 1. æƒ…ç»ªEmojiæ˜¾ç¤º
const EmotionEmoji = ({ emotion }: { emotion: EmotionType }) => (
  <Text style={styles.emotionText}>
    {EMOTION_EMOJIS[emotion]}
  </Text>
);

// 2. æ£€æµ‹çŠ¶æ€æŒ‡ç¤ºå™¨
const DetectionIndicator = ({ isDetecting }: { isDetecting: boolean }) => (
  isDetecting ? (
    <View style={styles.detectingIndicator}>
      <Text style={styles.detectingText}>â—</Text>
    </View>
  ) : null
);

// 3. Debugä¿¡æ¯å åŠ 
const DebugOverlay = ({ emotion, position, isDetecting }) => (
  isDebugMode() ? (
    <View style={styles.debugOverlay}>
      <Text>Emotion: {emotion}</Text>
      <Text>Position: {position.x}, {position.y}</Text>
      <Text>Detecting: {isDetecting ? 'Yes' : 'No'}</Text>
    </View>
  ) : null
);
```

---

## ğŸ” Debugå’Œç›‘æ§ç³»ç»Ÿ

### 1. åˆ†å±‚Debugæ¶æ„

#### Debugå·¥å…·é“¾
```typescript
// 1. ç¯å¢ƒå˜é‡æ§åˆ¶
const isDebugMode = (): boolean => {
  return Constants.expoConfig?.extra?.showTestComponents === true;
};

// 2. ç»„ä»¶çº§Debugæ—¥å¿—
export const debugLog = (component: string, message: string, data?: any) => {
  if (!isDebugMode()) return;
  
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] [${component}] ${message}`;
  
  if (data) {
    console.log(logMessage, data);
  } else {
    console.log(logMessage);
  }
};

// 3. æ€§èƒ½è®¡æ—¶å™¨
export class DebugTimer {
  constructor(private component: string, private label: string) {
    this.startTime = Date.now();
    debugLog(this.component, `Timer started: ${this.label}`);
  }
  
  end(): number {
    const duration = Date.now() - this.startTime;
    debugLog(this.component, `Timer ended: ${this.label} (${duration}ms)`);
    return duration;
  }
}
```

#### Metroé…ç½®ç›‘æ§
```javascript
// metro.config.js - Debugå¢å¼º
config.reporter = {
  update: (event) => {
    if (event.type === 'bundle_build_started') {
      console.log(`[Metro] Bundle build started for ${event.bundleDetails.platform}`);
    } else if (event.type === 'bundling_error') {
      console.error('[Metro] Bundling error:', event.error);
    }
  },
};
```

### 2. å®æ—¶ç›‘æ§æŒ‡æ ‡

#### æ€§èƒ½ç›‘æ§
```typescript
interface PerformanceMetrics {
  // ç»„ä»¶æ€§èƒ½
  initializationTime: number;      // åˆå§‹åŒ–è€—æ—¶
  emotionDetectionLatency: number; // æƒ…ç»ªæ£€æµ‹å»¶è¿Ÿ
  uiResponseTime: number;          // UIå“åº”æ—¶é—´
  
  // ç³»ç»Ÿæ€§èƒ½  
  memoryUsage: number;             // å†…å­˜å ç”¨
  cpuUsage: number;                // CPUä½¿ç”¨ç‡
  batteryImpact: 'low' | 'medium' | 'high'; // ç”µæ± å½±å“
  
  // ç”¨æˆ·ä½“éªŒ
  dragResponsiveness: number;      // æ‹–æ‹½å“åº”æ€§
  animationFrameRate: number;      // åŠ¨ç”»å¸§ç‡
}

// æ€§èƒ½æ•°æ®æ”¶é›†
const usePerformanceMonitor = () => {
  const metrics = useRef<PerformanceMetrics>({
    initializationTime: 0,
    emotionDetectionLatency: 0,
    // ... å…¶ä»–æŒ‡æ ‡
  });
  
  const recordMetric = (key: keyof PerformanceMetrics, value: number) => {
    metrics.current[key] = value;
    debugLog('PerformanceMonitor', `${key}: ${value}`, metrics.current);
  };
  
  return { metrics: metrics.current, recordMetric };
};
```

---

## ğŸš€ æ‰©å±•æ€§è®¾è®¡

### 1. æ’ä»¶åŒ–æ¶æ„

#### æƒ…ç»ªæ£€æµ‹æ’ä»¶æ¥å£
```typescript
interface EmotionDetectionPlugin {
  name: string;
  version: string;
  
  // æ ¸å¿ƒæ¥å£
  initialize(): Promise<void>;
  detectEmotion(input: any): Promise<EmotionDetectionResult>;
  cleanup(): void;
  
  // å…ƒæ•°æ®
  getSupportedEmotions(): EmotionType[];
  getCapabilities(): DetectionCapabilities;
}

// æ’ä»¶å®ç°ç¤ºä¾‹
class MLKitEmotionPlugin implements EmotionDetectionPlugin {
  name = 'MLKit Face Detection';
  version = '1.0.0';
  
  async initialize() {
    // MLKit åˆå§‹åŒ–
  }
  
  async detectEmotion(frame: Frame): Promise<EmotionDetectionResult> {
    // çœŸå®çš„MLKitæ£€æµ‹é€»è¾‘
    const faces = await this.mlkitDetector.detect(frame);
    return this.analyzeFaceData(faces[0]);
  }
  
  // ... å…¶ä»–å®ç°
}
```

#### æ’ä»¶ç®¡ç†å™¨
```typescript
class EmotionDetectionManager {
  private plugins: Map<string, EmotionDetectionPlugin> = new Map();
  private activePlugin: EmotionDetectionPlugin | null = null;
  
  registerPlugin(plugin: EmotionDetectionPlugin) {
    this.plugins.set(plugin.name, plugin);
  }
  
  async activatePlugin(name: string) {
    const plugin = this.plugins.get(name);
    if (plugin) {
      await plugin.initialize();
      this.activePlugin = plugin;
    }
  }
  
  async detectEmotion(input: any): Promise<EmotionDetectionResult> {
    if (!this.activePlugin) {
      throw new Error('No active emotion detection plugin');
    }
    return this.activePlugin.detectEmotion(input);
  }
}
```

### 2. é…ç½®é©±åŠ¨å¼€å‘

#### åŠ¨æ€é…ç½®ç³»ç»Ÿ
```typescript
interface EmotionDetectionConfig {
  // æ£€æµ‹è®¾ç½®
  detectionMode: 'simulation' | 'camera' | 'hybrid';
  detectionInterval: number;
  emotionThreshold: number;
  
  // UIé…ç½®
  allowDragging: boolean;
  showDebugInfo: boolean;
  position: { x: number; y: number };
  
  // ç®—æ³•å‚æ•°
  timeBasedWeights: boolean;
  emotionWeights: Record<EmotionType, number>;
  
  // æ€§èƒ½è®¾ç½®
  maxFrameRate: number;
  enablePerformanceMonitoring: boolean;
}

// é…ç½®ç®¡ç†
const useEmotionConfig = () => {
  const [config, setConfig] = useState<EmotionDetectionConfig>(DEFAULT_CONFIG);
  
  const updateConfig = (updates: Partial<EmotionDetectionConfig>) => {
    setConfig(prev => ({ ...prev, ...updates }));
  };
  
  return { config, updateConfig };
};
```

---

## ğŸ“Š æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•æ¶æ„

#### ç»„ä»¶æµ‹è¯•
```typescript
// BasicEmotionDetector.test.tsx
describe('BasicEmotionDetector', () => {
  it('should simulate emotion detection based on time', () => {
    const mockTime = new Date('2025-01-20T10:00:00Z'); // æ—©ä¸Š10ç‚¹
    jest.useFakeTimers().setSystemTime(mockTime);
    
    const onEmotionDetected = jest.fn();
    render(
      <BasicEmotionDetector 
        onEmotionDetected={onEmotionDetected}
        isActive={true}
        detectionInterval={1000}
      />
    );
    
    // éªŒè¯æ—¶é—´æ„ŸçŸ¥ç®—æ³•
    act(() => {
      jest.advanceTimersByTime(1000);
    });
    
    expect(onEmotionDetected).toHaveBeenCalled();
    // æ—©ä¸Šåº”è¯¥æœ‰æ›´é«˜çš„happyæ¦‚ç‡
    // ... æ›´å¤šæ–­è¨€
  });
});
```

#### ç®—æ³•æµ‹è¯•
```typescript
// emotionAlgorithm.test.ts
describe('æ™ºèƒ½æƒ…ç»ªç®—æ³•', () => {
  it('should return appropriate emotion weights for different times', () => {
    // æµ‹è¯•æ—©ä¸Šæƒé‡
    const morningWeights = calculateEmotionWeights(9);
    expect(morningWeights.happy).toBeGreaterThan(0.3);
    
    // æµ‹è¯•æ™šä¸Šæƒé‡  
    const eveningWeights = calculateEmotionWeights(22);
    expect(eveningWeights.neutral).toBeGreaterThan(0.5);
  });
  
  it('should select emotions according to weight distribution', () => {
    const weights = { happy: 1.0, neutral: 0, surprised: 0, sad: 0, angry: 0 };
    
    // å¤šæ¬¡é‡‡æ ·æµ‹è¯•
    const results = Array.from({ length: 100 }, () => 
      selectEmotionByWeight(weights)
    );
    
    expect(results.every(emotion => emotion === 'happy')).toBe(true);
  });
});
```

### 2. é›†æˆæµ‹è¯•

#### E2Eæµ‹è¯•æµç¨‹
```typescript
// emotionDetection.e2e.ts
describe('æƒ…ç»ªæ£€æµ‹å®Œæ•´æµç¨‹', () => {
  it('should integrate emotion detection with Live2D character', async () => {
    // 1. å¯åŠ¨åº”ç”¨
    await device.launchApp();
    
    // 2. å¯¼èˆªåˆ°ä¸»å±å¹•
    await element(by.text('å¼€å§‹ä½“éªŒ')).tap();
    
    // 3. éªŒè¯æƒ…ç»ªæ£€æµ‹å™¨å¯è§
    await expect(element(by.id('emotion-detector'))).toBeVisible();
    
    // 4. ç­‰å¾…æƒ…ç»ªæ£€æµ‹è§¦å‘
    await waitFor(element(by.id('emotion-indicator')))
      .toHaveText('ğŸ˜Š')
      .withTimeout(5000);
    
    // 5. éªŒè¯Live2Dè§’è‰²å“åº”
    await expect(element(by.id('live2d-character')))
      .toHaveAnimationState('Happy');
  });
});
```

---

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. æ¸²æŸ“ä¼˜åŒ–

#### Reactä¼˜åŒ–
```typescript
// 1. é€‚å½“çš„memoåŒ–
const BasicEmotionDetector = React.memo<EmotionDetectorProps>(
  ({ onEmotionDetected, isActive, detectionInterval }) => {
    // ... ç»„ä»¶å®ç°
  },
  (prevProps, nextProps) => {
    // è‡ªå®šä¹‰æ¯”è¾ƒé€»è¾‘
    return prevProps.isActive === nextProps.isActive &&
           prevProps.detectionInterval === nextProps.detectionInterval;
  }
);

// 2. useCallbackä¼˜åŒ–
const simulateEmotionDetection = useCallback(() => {
  // æƒ…ç»ªæ£€æµ‹é€»è¾‘
}, [isActive, detectionInterval, currentEmotion]); // ç²¾ç¡®ä¾èµ–

// 3. useMemoç¼“å­˜è®¡ç®—
const emotionWeights = useMemo(() => {
  return calculateEmotionWeights(new Date().getHours());
}, [Math.floor(Date.now() / (1000 * 60 * 60))]); // æ¯å°æ—¶æ›´æ–°
```

#### åŠ¨ç”»ä¼˜åŒ–
```typescript
// 1. ä½¿ç”¨runOnUIå‡å°‘æ¡¥æ¥å¼€é”€
const animatedStyle = useAnimatedStyle(() => {
  'worklet';
  return {
    transform: [
      { scale: scale.value },
      { translateX: position.value.x },
      { translateY: position.value.y }
    ]
  };
}, []);

// 2. æ‰¹é‡æ›´æ–°
const updatePositionAndScale = (newPosition: Position, newScale: number) => {
  'worklet';
  position.value = newPosition;
  scale.value = withSpring(newScale);
};
```

### 2. å†…å­˜ç®¡ç†

#### ç”Ÿå‘½å‘¨æœŸä¼˜åŒ–
```typescript
const BasicEmotionDetector: React.FC<EmotionDetectorProps> = (props) => {
  // 1. å®šæ—¶å™¨æ¸…ç†
  useEffect(() => {
    const interval = setInterval(simulateEmotionDetection, detectionInterval);
    return () => clearInterval(interval);
  }, [simulateEmotionDetection, detectionInterval]);
  
  // 2. åŠ¨ç”»å€¼æ¸…ç†
  useEffect(() => {
    return () => {
      scale.value = 1;
      // å…¶ä»–æ¸…ç†é€»è¾‘
    };
  }, []);
  
  // 3. äº‹ä»¶ç›‘å¬å™¨æ¸…ç†
  useEffect(() => {
    const subscription = AppState.addEventListener('change', handleAppStateChange);
    return () => subscription?.remove();
  }, []);
};
```

---

## ğŸ”’ å®‰å…¨å’Œéšç§

### 1. æ•°æ®å®‰å…¨

#### æœ¬åœ°å¤„ç†åŸåˆ™
```typescript
// æ‰€æœ‰æƒ…ç»ªæ£€æµ‹æ•°æ®æœ¬åœ°å¤„ç†ï¼Œä¸ä¸Šä¼ æœåŠ¡å™¨
const processEmotionData = (emotionData: EmotionDetectionResult) => {
  // 1. æœ¬åœ°å­˜å‚¨åŠ å¯†
  const encryptedData = encrypt(emotionData, LOCAL_KEY);
  AsyncStorage.setItem('emotion_cache', encryptedData);
  
  // 2. å†…å­˜ä¸­ä¸´æ—¶ç¼“å­˜
  const temporaryCache = new Map<string, EmotionDetectionResult>();
  
  // 3. å®šæœŸæ¸…ç†æ•æ„Ÿæ•°æ®
  setTimeout(() => {
    temporaryCache.clear();
  }, CACHE_TIMEOUT);
};
```

#### æƒé™ç®¡ç†
```typescript
// æ‘„åƒå¤´æƒé™æœ€å°åŒ–åŸåˆ™
const requestCameraPermission = async () => {
  const { status } = await Camera.requestCameraPermissionsAsync();
  
  if (status !== 'granted') {
    // æä¾›æ˜ç¡®çš„æƒé™è¯´æ˜
    Alert.alert(
      'æ‘„åƒå¤´æƒé™',
      'æƒ…ç»ªæ£€æµ‹åŠŸèƒ½éœ€è¦è®¿é—®æ‘„åƒå¤´æ¥åˆ†æé¢éƒ¨è¡¨æƒ…ï¼Œæ•°æ®ä»…åœ¨æœ¬åœ°å¤„ç†ã€‚',
      [
        { text: 'å–æ¶ˆ', style: 'cancel' },
        { text: 'æˆæƒ', onPress: () => Linking.openSettings() }
      ]
    );
  }
};
```

### 2. éšç§ä¿æŠ¤

#### æ•°æ®åŒ¿ååŒ–
```typescript
interface AnonymizedEmotionData {
  emotion: EmotionType;
  timestamp: number;
  sessionId: string; // éšæœºç”Ÿæˆï¼Œä¸å…³è”ç”¨æˆ·
  // ç§»é™¤æ‰€æœ‰å¯è¯†åˆ«ä¿¡æ¯
}

const anonymizeEmotionData = (
  data: EmotionDetectionResult
): AnonymizedEmotionData => ({
  emotion: data.emotion,
  timestamp: Math.floor(data.timestamp / (1000 * 60 * 5)) * (1000 * 60 * 5), // 5åˆ†é’Ÿç²¾åº¦
  sessionId: generateRandomSessionId()
});
```

---

*æ–‡æ¡£ç‰ˆæœ¬: 1.0.0*  
*æœ€åæ›´æ–°: 2025-01-20*  
*æŠ€æœ¯æ ˆ: React Native 0.79.5 + Expo 53 + TypeScript*